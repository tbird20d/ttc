#!/usr/bin/python
# vim: set ts=4 sw=4 et :
#
# ttc - 'tiny target control' - a tool for building source and
# manipulating a target from a host
# Don't let anyone tell you that 'ttc' stands for "Tim's Target Control"
# It's just not true.
#
# Copyright 2022 Sony Corporation
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of version 2 of the GNU General Public License as
#   published by the Free Software Foundation.  The GNU General Public
#   License is available online at: http://www.gnu.org/copyleft/gpl.html
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
# Author: Tim Bird  <tim.bird (at) sony.com>
#
# To Do:
#  * should support INSTALL_MOD_PATH
#
# CHANGELOG:
#  2.2.0  - Support duration option for ttc reserve
#  2.1.1  - Support TTC_TARGET for remote targets (after ttc setenv)
#  2.1.0  - Add support for federated ttc hosts.  This means ttc can
#           transparently support operations on a board on a remote host.
#           Some operations are local (such as kbuild or set_config), even
#           when the board is remote.
#  2.0.4  - Add --debug option, and use with do_run()
#           Also, use debug_%(command)s_run, if present, when executing a
#           command from the conf file, and we're in debug mode
#  2.0.3  - Fix help for status and pos.
#  2.0.2  - Add support for fuego system conf (/fuego-rw/conf instead of /etc)
#  2.0.1  - Fix bug using subprocess.getstatusoutput (part of py3 conversion)
#  2.0.0  - add support for the python 3 interpreter
#           Also, convert all tabs to spaces.
#           And eliminate use of print with a trailing comma.
#  1.5.4  - stop processing args after 'run' command is detected
#  1.5.3  - fix bug with ttc run and quoting
#  1.5.2  - allow quotes around single-line values
#  1.5.1  - fix bug when no config files found
#  1.5.0  - change 'ttc run' to perform an exec
#  1.4.4  - add support for ~/.config/ttc.conf, and change config file handling
#           so that /etc/ttc.conf is optional
#  1.4.3  - add mbuild and minstall
#  1.4.2  - add command status to do 'status' command
#  1.4.1  - add power status and network status to 'status' command
#  1.4.0  - pass multiple args to run command (everything following 'run' in
#           command line).  Also, remove trailing whitespace from some lines.
#  1.3.4  - support leading '-r' in copy commands, and pass it to
#           sub-command in 'copy_args' environment variable
#  1.3.3  - add -c command, support TTC_SYSLOG, handle missing /dev/log
#  1.3.2  - allow whitespace preceding comment char: #
#  1.3.1  - change author e-mail to sonymobile.com
#  1.3.0  - 2013-01-22 add on, off, pos, fsbuild commands
#  1.2.3  - add error handling for macro expansions
#  1.2.2  - add ADBHOST to list of environment variables set on setenv
#  1.2.1  - 2011-06-16 flush stdout after ttc run, to avoid a python exception
#           when output is piped to a command which terminates.
#           e.g. ttc run dmesg | head
#  1.2.0  - ??
#  1.1.0  - 2011-04-18 support multi-line shell fragments in exec_command
#  1.0.1  - 2011-01-11 fix bug handling single-line triple-quoted blocks
#  1.0.0  - 2008-10-24 rename LOCAL_TTC_CONF to TTC_CONF and support multiple
#           config files
#  0.9.22 - 2008-10-23 rename to ttc
#  0.9.12 - 2008-08-13 Remove spurious prints from set_config
#  0.9.11 - 2008-06-19 Escape spaces in exported env vars for "setenv -o"
#           This is needed to handle CROSS_COMPILE=ccache arm-linux-
#  0.9.10 - 2008-06-05 Fix macro expansion to ignore non-interpolation percents: %PTR%
#  0.9.9 - 2008-06-03 Expand nested macros
#  0.9.8 - 2008-05-21 Support expansion macros in attributes
#          Also, support multi-value and multi-level inheritance
#          Support hidden config blocks (starting with a dot)
#  0.9.7 - 2008-05-12 Support inheritance using the inherit_from attribute

import os, sys, re
import shutil
import shlex
import time
import datetime

# handle missing routines from python2 or python3 modules
try:
    from subprocess import getstatusoutput
except:
    from commands import getstatusoutput

# MAJOR, MINOR, REVISION (or PATCH)
VERSION = (2,2,1)
# NOTE: make sure to change ttc-dist.sh to match

# lockdir is the place where reservation files are kept
lockdir = "/tmp/ttc-reservations"
rfile_fmt = "%s/%s.res"

quiet = 0
verbose = 0
debug = False

# keep configuration file in /etc
system_config_dir = "/etc"
fuego_config_dir = "/fuego-ro/conf"
user_config_dir = os.path.expanduser("~/.config")
CONFIG_FILE = "ttc.conf"

system_conf = system_config_dir + "/" + CONFIG_FILE
fuego_conf = fuego_config_dir + "/" + CONFIG_FILE
user_conf = user_config_dir + "/" + CONFIG_FILE

# This is the name of the environment variable
# used to keep track of the current target
TARGET_ENV_VAR="TTC_TARGET"

# specify local configuration file via an environment variable
LOCAL_CONF_ENV_VAR="TTC_CONF"

# specify logging variable
LOG_ENV_VAR="TTC_SYSLOG"

# format for command_help mapping with: key=name, value=(summary, long description)
# if
command_help = {
"cp":("Copy files to or from the target.",
"""Usage: ttc [<target>] cp <src> [<src2> ...] <dest>
  The last file specified determines the direction of the copy.
  Use the prefix "target:" to specify a filepath
  on the target.  "target_bin:" can be used to put a file on the target
  in a directory on the PATH."""),

"console":("Run a program to view the target console.", ""),

"list":("Show a list of available targets.",
"""Usage: ttc [-q]
  Prints target board names with their aliases and 'real_board'
  attributes, if any.

  Use -q for "quiet" mode.  This prints only the board names, with no
  additional information. This is suitable for piping to other commands."""),

"info":("Show information about a target.",
"""Usage: ttc [<target>] info [-v] [-n <attr>]
  Show information about a target.  The '-v' (verbose) option will show all the
  attributes for the target (from the configuration file).  Use the '-n' option
  to display the value of a single attribute, <attr>."""),

"release":("Release a reservation of a target.",
"""Usage: ttc [<target>] release [-f]
  This releases (terminates) the current reservation for a target.
  If you don't currently have the reservation, an error will be shown.
  Use '-f' to force releasing the reservation of another user."""),

"reserve":("Reserve a target for use.",
"""Usage: ttc [<target>] reserve [-f] [<duration-str>]
  Reserve a target for use.  This puts a lock file in place
  to advise other users that you are using the board.  Use 'ttc release'
  to remove the reservation.  If '-f' (force) is specified, then
  release any prior reservation.

  An optional duration may be specified.  If duration-str is omitted,
  the target is reserved for 4 hours.

  <duration-str> is a string of the form: xxhyym where xx is the
  number of hours and yy is the number of minutes.  Either hours
  or minutes may be omitted.  ex: 1h30m = 90 minute reservation
  ex: 15m = 15 minute reservation."""),

#"""Usage: ttc [<target>] reserve [<duration-str>] [-s <start-time>]
#  ...
#  A target may define a default duration.  "forever" means the
#  duration lasts indefinitely (does not expire automatically,
#  after a period of time)
#
#  if start-time is omitted, starting time is now.
#  Use a duration of 0 to cancel a reservation in the future.
#"""),

"status":("Show status of target, including reservations.",
    """Usage: ttc [<target>] status
  Shows the power, network, command and reservation status for a
  target.  The network status indicates whether the board responds
  to a network ping.  The command status indicates whether the board
  can execute a command.

  Power status is one of: ON, OFF, UNKNOWN
  Network status is one of: RESPONSIVE, NONRESPONSIVE
  Command status is one of: OPERATIVE, INOPERATIVE
  Reservation status shows "not reserved", or information about the
      current reservation
"""),

"setenv":("Prepare environment for building for target.",
"""Usage: ttc [<target>] setenv [-o >file]
  -o causes the environment to be output as a series of shell
  export statements, suitable to being sourced in the current shell.
  (e.g. ttc setenv -o >foo ; source foo)
  Normally, a new sub-shell is started.  When -o is used, no new
  sub-shell is started."""),

"login":("Run a program to perform a network login on the target.",""),

"help":("Show this online help.",
"""Usage: ttc help [<command>]
  If a command is specified, show the usage information for that command."""),

"version":("Show version information and exit.",
"""Usage ttc [<board>] version
  If a remote board is specified, then the version of ttc on the host for
  that board is shown."""),

"get_kernel":("Install kernel sources for target in the $KERNEL_SRC directory",
"""Usage: ttc [<target>] get_kernel [-o <outputdir>]
  Use -o to specify a specific output kernel source directory.
  (default is 'linux')"""),

"get_config":("Install kernel config for target in the $KBUILD_OUTPUT directory",
"""Usage: ttc [<target>] get_config [-o <outputdir>]
  Use -o to specify an alternate KBUILD_OUTPUT directory (default is '.')"""),

"set_config":("Set one or more individual config options",
"""Usage: ttc [<target>] set_config [-o <outputdir>] <option-def> ...

  Use -o to specify an alternate KBUILD_OUTPUT directory. (The default is '.'
  if none is specified in the ttc.conf file.)

  Multiple <option-defs> may be specified with one command.  Each
  <option-def> has the syntax: <option-name><operation><value>.i
  Operations are: '=' for assignment, and '+=' for a string append.
  Boolean or tristate values should be one of "y", "n", and "n".
  String values must be enclosed in quotes, which usually requires shell
  escaping of the quote characters (see below).

  A backup is made of the .config file.

  Ex. ttc set_config CONFIG_FOO=y
      ttc set_config CONFIG_BAR=n CONFIG_BAZ=1234
      ttc set_config "CONFIG_STR=\\"foo bar\\""
      ttc set_config "CONFIG_STR+=\\" quiet\\""
"""),

"kbuild":("Build kernel from source.",
"""Usage: ttc [<target>] kbuild"""),

"kinstall":("Install kernel for use on target.",
"""Usage: ttc [<target>] kinstall"""),

"mbuild":("Build kernel modules from source.",
"""Usage: ttc [<target>] mbuild"""),

"minstall":("Install kernel modules for use on target.",
"""Usage: ttc [<target>] minstall"""),

"fsbuild":("Build root filesystem for use on target.",
"""Usage: ttc [<target>] fsbuild"""),

"fsinstall":("Install root filesystem for use on target.",
"""Usage: ttc [<target>] fsinstall"""),

"on":("Turn on target board.",
"""Usage: ttc [<target>] on"""),

"off":("Turn off target board.",
"""Usage: ttc [<target>] off"""),

"pos":("Show power status of target board.",
"""Usage: ttc [<target>] pos
  Shows the power status of the board.  This command emits the
  string ON, OFF or UNKNOWN."""),

"reset":("Reset target board.",
"""Usage: ttc [<target>] reset [-w]
Use -w to have ttc wait a period of time before returning,
to allow the board to reset."""),

"reboot":("Reboot target board.",
"""Usage: ttc [<target>] reboot [-w]
Use -w to have ttc wait a period of time before returning,
to allow the board to reboot."""),

"rm":("Remove files from the target.",
"""Usage: ttc [<target>] rm <file1> [<file2> ...]"""),

"run":("Run a command on the target.",
"""Usage: ttc [<target>] run "command <args>" """),

"wait_for":("Wait for a condition to be true.",
"""Usage: ttc [<target>] wait_for [-i <interval>] [-t <timeout>] <command>
 The command is run periodically until it returns 0.  By default,
 the interval between executing the command is 5 seconds.
 Use -i to specify a different interval, and -t to specify a
 maximum time to wait.  Both are expressed in seconds.

   ex: ttc wait_for -i 2 -t 100 "test -f /tmp/outfile"

 This will check every two seconds to see if /tmp/outfile exists,
 waiting no longer than 100 seconds total. The exit code from
 'ttc' is the exit code of the last invocation of the
 command (0 on success)."""),

"vars":("Information about environment vars used by 'ttc'",
"""Target uses the following environment variables, if present:
TOOL_PATH, ARCH, CROSS_COMPILE, KBUILD_OUTPUT, TMPDIR, BUILDDIR,
%s, %s, %s
See the code for the meaning and usage of each of these variables.
(See do_setenv() for the complete list)

The order of reading configuration values is:
 1. read the global config file (%s)
    or, the fuego config file, if present (%s)
 2. read the user config file (%s)
 3. read a local config file (if specified by %s)
 4. read environment variables

Values specified in the local config file override values in the global config
file, and values in the environment override values in either config file.
""" % (TARGET_ENV_VAR, LOCAL_CONF_ENV_VAR, LOG_ENV_VAR,
       system_conf, fuego_conf, user_conf,
       LOCAL_CONF_ENV_VAR )),
}

def dprint(msg):
    # show a message if we're in debug mode
    global debug
    if debug:
        print("DEBUG: " + msg)

def vprint(msg):
    # show a message if we're in verbose mode
    global verbose
    if verbose:
        print(msg)

def usage(rcode, options=[]):
    command = ""
    if len(options):
        command = options[0]

    # check if command is legal
    if command and command not in list(command_help.keys()):
        print("Unknown command: %s" % command)
        command = ""
        # drop through to showing list of commands

    if not command:
        # show list of commands
        print("""Usage: ttc [global_options] [<target>] command [options]

where <target> is the name of a target connected to this host.
If <target> is omitted, then the current target is assumed
(the one specified in the %s environment variable).

Here are the available global options:
 -h, --help  Show this usage help
 -v          Be verbose
 -q          Be quiet
 -c          Use internal command (not 'system') to execute shell commands
 --debug     Show debug output on some commands

command is one of:
""" % (TARGET_ENV_VAR))
        command_list = list(command_help.keys())
        command_list.sort()
        for command in command_list:
            print("  %10s %s" % (command, command_help[command][0]))
    else:
        # print help for individual command
        print("ttc %s: %s" % (command, command_help[command][0]))
        print("")
        print(command_help[command][1])

    sys.exit(rcode)

def print_error(message):
    sys.stderr.write("Error: "+message+"\n")
    sys.stderr.flush()

# rcode meanings:
#   1 = general (missing command or args, or invalid args)
#   2 = unknown or missing target
#   3 = config problem
#   5 = local file operation problem
#   6 = syntax problem in copy operation
#   7 = problem with remote operation on ttc host
def error_out(message, rcode):
    print_error(message)
    sys.exit(rcode)

# conf file syntax
# returns 2 maps: targets and hosts
# targets is a map of maps, with target attributes in subsidiary map
# hosts is a map of maps, with host attributes in subsidiary map
# key for top level map is target or host name

# ttc configuration (ttc.conf) file syntax:
# ------------------------
# empty lines and lines starting with # are ignored
# target blocks begin with "target=<name>" and end when the
#   next target block is encountered.
# single-line attributes are:
# name=value
# multi-line attributes are:
# name="""value line 1
# value line 2, etc."""

def read_config(config_path, optional=True):
    # look in configuration directory
    config_file = os.path.basename(config_path)
    try:
        fl = open(config_path)
    except:
        if optional:
            return ({}, {})
        else:
            error_out("Cannot open configuration file %s" % config_path, 3)

    targets = {}
    target = "not found"
    hosts = {}
    host = "not found"
    in_target = False
    in_host = False
    in_block = False
    block = ""
    line_no = 0
    for line in fl.readlines():
        line_no += 1
        if line.lstrip().startswith("#"):
            continue
        if in_block:
            # try to find end of block
            if line.rstrip().endswith('"""'):
                # remove quotes and end block
                line = line.rstrip()
                block += line[:-3] + "\n"
                if in_target:
                    targets[target][name] = block
                elif in_host:
                    hosts[host][name] = block
                else:
                    print_error("end of block found outside of target or host definition in config file %s, at line %d" % (config_file, line_no))
                in_block = False
                continue
            else:
                block += line
                continue

        # 'target=' or 'host=' inside a block will be confusing to the user
        # but the code (above) ignores it

        # if we're outside a block, look for the start of a new target
        if line.startswith("target="):
            target = line.split("=")[1].strip()
            # start a new target map
            if target in targets:
                print_error("redefining target '%s' in configuration file %s, at line %d" % (target, config_path, line_no))
            targets[target]={}
            targets[target]["target"] = target
            in_target = True
            in_host = False
            continue

        # if we're outside a block, look for the start of a new host
        if line.startswith("host="):
            host = line.split("=")[1].strip()
            # start a new host map
            if host in hosts:
                print_error("redefining host '%s' in configuration file %s, at lne %d" % (host, config_path, line_no))
            hosts[host]={}
            hosts[host]["host"] = host
            in_host = True
            in_target = False
            continue

        # OK, it's not a target, host, comment or middle of a block.
        # check if it's empty
        if not line.strip():
            continue

        # line better have an equals in it
        # (either single line name=value, or multi-line block start)
        if line.find("=")==-1:
            print_error("Syntax error in config file %s: Expected '=' at line %d:\n%s" % (config_file, line_no, line))
            continue

        (name, value) = line.split('=', 1)
        name = name.strip()
        value = value.strip()
        if value.find('"""')==-1:
            # this is a single-line, just record the attribute
            if value.startswith('"') and value.endswith('"'):
                value = value[1:-1]
            if in_target:
                targets[target][name] = value
            elif in_host:
                hosts[host][name] = value
            else:
                print_error("attribute definition for '%s' found outside of target or host definition in config file %s, at line %d" % (name, config_file, line_no))
        else:
            # this is the start of a multi-line block
            vstart = value.find('"""')
            block = value[vstart+3:] + '\n'
            in_block = 1
            # sanity check for block terminator on same line
            # if triple-quotes end this line, then block begins
            # and ends on the same line.
            if block.endswith('"""\n'):
                block = block[:-3]
                if in_target:
                    targets[target][name] = block
                elif in_host:
                    hosts[host][name] = block
                else:
                    print_error("attribute definition for '%s' found outside of target or host definition in config file %s, at line %d" % (name, config_file, line_no))

                in_block = 0


    # check to see if any attributes are "homeless"
    if "not found" in targets or "not found" in hosts:
        print_error("Some attributes found outside of target or host blocks in file %s" % config_file)

    if not targets and not hosts:
        print_error("No targets or hosts were found in file %s" % config_file)

    #print("targets="+str(targets))
    #print("hosts="+str(hosts))
    return (targets, hosts)

def do_list(targets, hosts):
    global quiet, verbose

    if quiet:
        prefix = ""
        quiet_arg = "-q"
    else:
        prefix = "    "
        quiet_arg = ""

    # get local targets
    target_list = list(targets.keys())

    # format data for my local targets
    output_lines = []
    for target in target_list:
        # omit hidden config blocks
        if target.startswith('.'):
            continue
        talias = ''
        if not quiet and "target_alias" in targets[target]:
            talias = " (alias %s)" % targets[target]["target_alias"]

        treal = ''
        if not quiet and "real_board" in targets[target]:
            treal = " (real %s)" % targets[target]["real_board"]

        output_lines.append("%s%s%s%s" % (prefix, target, talias, treal))

    # get targets from other hosts, and format the data
    # (add host prefix to target, alias and real-board info)
    for host in hosts:
        dprint("reading data from host: %s" % host)
        hmap = hosts[host]
        hostname = hmap.get("hostname", host)

        # filter by target_pat_list, if specified
        # target_pat_list holds the a colon-delimited list of regular expression
        # patterns for boards on this host to allow operations on
        # if no target_pat_list is defined, all boards are used
        # (ie, there is no filtering)
        target_pat_list = hmap.get("target_pat_list", ".*")
        tpats = target_pat_list.split(":")

        exec_cmd=hmap.get("exec_cmd", "/usr/bin/ssh")

        exec_args_str=hmap.get("exec_args", "-t -q -o ConnectTimeout=2")
        exec_args = shlex.split(exec_args_str)

        cmd_args = [exec_cmd] + exec_args + [hostname, "ttc", quiet_arg, "list"]

        cmd = " ".join(cmd_args)
        dprint("cmd=%s" % cmd)
        (rcode, result) = getstatusoutput(cmd)
        dprint("rcode=%d" % rcode)
        #print("result=%s" % result)
        if rcode != 0:
            print_error("problem reading targets from host %s" % host)
            continue

        lines = result.split('\n')

        for line in lines:
            dprint("line=%s" % line)
            # skip non-target lines
            if line.startswith("Error:"):
                continue
            if line.startswith("Targets:"):
                continue
            if line.startswith("DEBUG:"):
                continue
            parts = line.strip().split(" ")
            target = parts[0]
            full_target = host + ":" + target

            use_target = False
            for pat in tpats:
                if re.match(pat, target):
                    use_target = True
                dprint("pat=%s, target=%s, use_target=%s" % (pat, target, use_target))
            if not use_target:
                continue

            talias = ''
            if "(alias" in parts:
                a_str = parts[parts.index("(alias")+1][:-1]
                talias = " (alias %s:%s)" % (host, a_str)
            treal = ''
            if "(real" in parts:
                r_str = parts[parts.index("(real")+1][:-1]
                talias = " (real %s:%s)" % (host, r_str)

            output_lines.append("%s%s%s%s" % (prefix, full_target, talias, treal))

    output_lines.sort()

    # show title
    if not quiet:
        if hosts:
            print("Targets:")
        else:
            print("Targets on this host:")

    for line in output_lines:
        print(line)

    sys.exit(0)

def is_remote(tmap):
    if ":" in tmap["target"]:
        return True
    else:
        return False

def do_remote_command_exec(hmap, tmap, command, options):
    global quiet, debug, verbose

    hostname = hmap.get("hostname", hmap["host"])
    full_target = tmap["target"]
    dprint("full_target='%s'" % full_target)
    remote_target = full_target.split(":", 1)[1]
    dprint("remote_target='%s'" % remote_target)
    ttc_has_debug = hmap.get("ttc_has_debug", "0")
    if ttc_has_debug in ["true", "True", "1"]:
        remote_ttc_has_debug = True
    else:
        remote_ttc_has_debug = False

    exec_cmd=hmap.get("exec_cmd", "/usr/bin/ssh")

    exec_args_str=hmap.get("exec_args", "-t -q -o ConnectTimeout=2")
    exec_args = shlex.split(exec_args_str)

    cmd_args = [exec_cmd] + exec_args + [hostname, "ttc"]

    # add ttc global args
    if quiet: cmd_args.append("-q")
    if verbose: cmd_args.append("-v")
    if remote_ttc_has_debug and debug: cmd_args.append("--debug")

    cmd_args.append(remote_target)
    cmd_args.append(command)

    # add command arguments
    for opt in options:
        if " " in opt:
            if not opt.startswith('"'):
                opt = '"' + opt + '"'
        cmd_args.append(opt)

    # show what we're about to do
    dprint("os.execvp(%s, %s)" % (exec_cmd, cmd_args))

    # make sure nothing is left in python file buffers
    try:
        sys.stdout.flush()
        sys.stderr.flush()
    except IOError:
        pass
    os.execvp(exec_cmd, cmd_args)

def do_info(tmap, options):
    global verbose

    attrs = list(tmap.keys())
    attrs.sort()
    target_name = tmap["target"]

    # print a single data item, if requested
    if '-n' in options:
        attr = options[options.index('-n')+1]
        options.remove('-n')
        options.remove(attr)
        try:
            value = tmap[attr]
        except:
            print_error("target '%s' has no attributed '%s'." % (target_name, attr))
            sys.exit(1)
        print(value)
        return

    print("Information for target: %s\n" % target_name)
    attrs.remove("target")

    if "description" in tmap:
        desc = tmap["description"]
        print(desc)
        attrs.remove("description")

    if not verbose:
        # just print description, nothing more
        return

    for attr in attrs:
        value = tmap[attr]
        if value.find('\n')==-1:
            # print single-line value
            print("%15s : %s" % (attr, tmap[attr]))
        else:
            # print multi-line value
            lines = value.split('\n')
            print("%15s : %s" % (attr, lines[0]))
            # subsequent lines are indented
            for line in lines[1:]:
                print(" "*18 + line)

def exec_command(tmap, command, use_system=1):
    global verbose
    global quiet
    global use_statusoutput
    global debug

    cmd_block = ""
    try:
        cmd_block = tmap[command+"_cmd"]
    except:
        pass

    # check for debug version of command, if we're in debug mode
    if debug:
        try:
            cmd_block = tmap["debug_"+command+"_cmd"]
        except:
            pass

    if not cmd_block:
        error_out('%s_cmd not configured for target %s' % (command, tmap["target"]), 3)

    # cmd can be a single line, or a list of commands to run
    # lines can be continued with a trailing \
    cmds = cmd_block.split('\n')
    full_cmd = ""
    for cmd in cmds:
        dprint("cmd="+cmd)
        cmd = cmd.strip()
        if not cmd:
            continue
        full_cmd += cmd
        if full_cmd.endswith("\\"):
            full_cmd += '\n'
            continue

        dprint("full_cmd={{{"+full_cmd+ "\n}}}")

        saved_cmd = full_cmd
        # execute full_cmd
        if use_system and not use_statusoutput:
            syscode = os.system(full_cmd)
            rcode = os.WEXITSTATUS(syscode)
            # signal = syscode & 0xff
            full_cmd = ""
            result = ""
        else:
            (rcode, result) = getstatusoutput(full_cmd)
            full_cmd = ""
        if not quiet:
            if verbose:
                sys.stdout.write("result=")
            sys.stdout.write(result)
            try:
                sys.stdout.flush()
            except:
                pass
        if rcode:
            print_error('Bad result %d, running "%s": (output follows)' % (rcode, saved_cmd))
            print_error(result)
            sys.exit(2)

    if full_cmd:
        print_error('Error - trailing slash on last non-empty line of %s_cmd\nCommand was NOT executed.' % command)
        sys.exit(3)

# cmd can be a single line, or a list of commands to run
# NOTE: this does not support line continuation.
# The last line of the command block will be fork and exec'ed.
# For all but the last command, use getstatusoutput.
# This code assumes all but the last command run quickly.
def do_run(tmap, options):
    global verbose
    global quiet
    global debug

    cmd_to_run = " ".join(options)
    # um, we just lost all quoting

    os.environ["COMMAND"] = cmd_to_run

    cmd_block = ""
    try:
        cmd_block = tmap["run_cmd"]
    except:
        pass

    # check for debug version of command, if we're in debug mode
    if debug:
        try:
            cmd_block = tmap["debug_run_cmd"]
        except:
            pass

    if not cmd_block:
        print_error('run_cmd not configured for target %s' % (tmap["target"]))

    # cmd can be a single line, or a list of commands to run
    cmds = cmd_block.split('\n')
    last_cmd = cmds[-1]
    for cmd in cmds[:-1]:
        if verbose:
            print("cmd='%s'" % cmd)
        cmd = cmd.strip()
        if not cmd:
            continue

        # execute cmd
        dprint("getstatusoutput(\"%s\")" % cmd)
        (rcode, result) = getstatusoutput(cmd)
        if not quiet:
            if verbose:
                sys.stdout.write("result=")
            sys.stdout.write(result)
            try:
                sys.stdout.flush()
                sys.stderr.flush()
            except:
                pass
        if rcode:
            print_error('Bad result %d, running "%s": (output follows)' % (rcode, cmd))
            print_error(result)
            sys.exit(rcode)

    if verbose:
        print("cmd='%s'" % last_cmd)

    exec_args = shlex.split(last_cmd)
    # NOTE: shlex.split removes the quotes around "$COMMAND", if present

    # copy args and check for substitution one-by-one
    new_exec_args = []
    for arg in exec_args:
        if "$COMMAND" in arg:
            if '"$COMMAND"' in last_cmd:
                # if $COMMAND was quoted, then keep as one arg
                # this is another band-aid on this tough problem
                new_exec_args.append(cmd_to_run)
            else:
                # otherwise, add as separate args
                new_exec_args.extend(options)
        else:
            new_exec_args.append(arg)
    exec_args = new_exec_args

    # make sure nothing is left in python file buffers
    try:
        sys.stdout.flush()
        sys.stderr.flush()
    except IOError:
        pass
    dprint("os.execvp(%s, %s)" % (exec_args[0], exec_args))
    os.execvp(exec_args[0], exec_args)

# returns one of: 'UKNOWN', 'ON', 'OFF'
def power_status(tmap):
        pos_str = "UNKNOWN"
        if 'pos_cmd' in tmap:
            (rcode, result) = getstatusoutput( \
                    "ttc %s pos" % tmap["target"])
            m = re.search(r"\b(off|on)\b", result, re.IGNORECASE)
            if m:
                pos_str = m.groups()[0].upper()

        return pos_str

# returns one of: 'RESPONSIVE', 'NONRESPONSIVE', 'UNKNOWN'
def network_status(tmap):
        ip_addr = tmap.get("ip_addr", "")
        if not ip_addr:
            print("Warning: missing ip_addr attriute for target '%s'" % tmap["target"])
            return "UNKNOWN"

        rcode, result = getstatusoutput("ping -c 5 -i 0.3 -W 1 %s" % ip_addr)
        if rcode==0:
            return "RESPONSIVE"
        else:
            return "NONRESPONSIVE"

# returns one of: 'OPERATIVE', 'INOPERATIVE'
def command_status(tmap):
        # even users who don't have a reservation can check the status
        # of a target

        # use --no-check to avoid checking the reservation
        rcode, result = getstatusoutput( \
                'ttc --debug --no-check %s run echo \"hello response\"' % tmap["target"])

        # FIXTHIS - not sure what to do if user doesn't have reservation
        # this returns INOPERATIVE, because ttc run fails

        m = re.search(r"hello response", result)
        if m:
            return "OPERATIVE"
        else:
            return "INOPERATIVE"

def do_status(tmap):
    target = tmap["target"]

    # this might clear an expired reservation
    res = get_reservation(tmap)

    print("Status for target: %s" % target)

    power_str = power_status(tmap)
    print("Power to board is: %s" % power_str)

    # is target pingable? (network is active?)
    net_str = network_status(tmap)
    print("Network status is: %s" % net_str)

    cmd_str = command_status(tmap)
    print("Command status is: %s" % cmd_str)

    # show who is currently using target
    res = get_reservation(tmap)
    if res:
        print(res.get_str())
    else:
        print("Target board is not reserved.")
    sys.exit(0)

    # FIXTHIS - should report:
    #    future reservations for target?

# set the vars from tmap into the current environment
# if options list has "-o", output the env as a list of shell export statements
# if options list has "-s", start a sub-shell
#
# variable precedence:
#   value from 'target' command line = highest precedence
#   value from pre-existing environment = medium precedence
#   value from target.conf file = lowest precendence
#
# This means that effectively, target commands don't "nest" if
# a different target is specified.  This is because the target.conf
# values for a new target would not override the values in the
# sub-shell environment of the first target.
# (i.e. bad things will happen if you do: "target setenv osk", then
#   "target ebony getkernel ; make $kimage" )
#
# FIXTHIS - should check for pre-existing TTC_TARGET variable and warn user
#
def do_setenv(tmap, options=[]):
    if "-s" in options:
        print("Setting environment for target: %s" % tmap["target"])

    # set target name in new shell environment
    os.environ[TARGET_ENV_VAR] = tmap["target"]

    # copy certain environment vars for the new shell
    env_list = ["ARCH", "CROSS_COMPILE", "kimage", "INSTALL_PATH",
        "INSTALL_MOD_PATH", "ADBHOST", "BUILDDIR",
        "KERNEL_SRC", "KBUILD_OUTPUT", "SSHPASS",
        "TOOL_PATH", "TMPDIR"]

    for var in env_list:
        if var in tmap and tmap[var] and var not in os.environ:
            os.environ[var]=tmap[var]

    # add TMPDIR if not already present
    if "TMPDIR" not in os.environ:
        os.environ["TMPDIR"] = "/tmp"

    # if TOOL_PATH is present, add it to regular PATH, if not already there
    if "TOOL_PATH" in tmap:
        tool_path = tmap["TOOL_PATH"]
        PATH = os.environ["PATH"].split(":")
        for tool_path_item in tool_path.split(":"):
            if tool_path_item not in PATH:
                PATH.append(tool_path_item)
        os.environ["PATH"] = ":".join(PATH)
        # DEBUG
        #print("os.environ['PATH']="+os.environ["PATH"])

    # if output of export list is requested, do that
    if "-o" in options:
        export_list = env_list + ["PATH", TARGET_ENV_VAR]
        for var in export_list:
            if var in os.environ:
                value = os.environ[var]
                # escape spaces
                value = re.sub(" ","\ ",value)
                print("export %s=%s" % (var, value))
        return

    # do sanity checks, or other environment setup, if configured
    # note that setenv is called every time ttc is run, so this can
    # be used as a global environment sanity check over anything
    # you probably shouldn't do something persistent here
    if "setenv_cmd" in tmap:
        exec_command(tmap, "setenv", 1)

    if "-s" in options:
        # start a new shell with the modified environment
        # FIXTHIS - add TTC to prompt
        #print("os.environ="+os.environ)
        #prompt = os.environ["PS1"]
        #prompt = prompt[0] + "TTC " + prompt[1:]
        #os.environ["PS1"] = "[TTC \\u@\\h \\W]\\$ "

        # FIXTHIS - should get user's preferred shell from /etc/passwd
        print("Starting sub-shell with environment for target.")
        print("Use 'exit' to exit the sub-shell.")
        os.system("/bin/bash")

def do_get_kernel(tmap, hosts, options):
    global debug

    # set directory to output kernel to
    if "-o" in options:
        # override the KERNEL_SRC directory in the environment
        try:
            outdir = options[options.index("-o")+1]
        except IndexError:
            error_out("Missing argument for -o option", 1)
    else:
        outdir = "linux"

    # handle local operation
    if not is_remote(tmap):
        os.environ["KERNEL_SRC"] = outdir
        exec_command(tmap, command)
        return

    # target is remote: do get_kernel on host, then copy to local dir
    hmap = hosts[tmap["host"]]

    dprint("in do_get_kernel (remote)")

    # outline of remote operations:
    #   do (on host) 'ttc <target> get_kernel -o staging_dir'
    #   then 'scp host:<staging_dir> outdir'
    #   then (on host) 'rm -rf staging_dir'

    hostname = hmap.get("hostname", hmap["host"])
    full_target = tmap["target"]
    remote_target = full_target.split(":", 1)[1]
    ttc_has_debug = hmap.get("ttc_has_debug", "0")
    if ttc_has_debug in ["true", "True", "1"]:
        remote_ttc_has_debug = True
    else:
        remote_ttc_has_debug = False

    exec_cmd=hmap.get("exec_cmd", "/usr/bin/ssh")
    exec_args_str=hmap.get("exec_args", "-t -q -o ConnectTimeout=2")
    exec_args = shlex.split(exec_args_str)

    # set ttc global args for remote ttc operation
    extra_ttc_args = []
    if remote_ttc_has_debug and debug:
        extra_ttc_args.append("--debug")

    # set staging dir name
    import random
    uid = random.randint(0,100000)
    staging_dir = "/tmp/ttc-gk-staging-%06d" % uid

    # do 'ttc <target> get_kernel -o <staging_dir>'
    cmd_args = [exec_cmd] + exec_args + [hostname, "ttc"] + extra_ttc_args + \
       [remote_target, "get_kernel", "-o", staging_dir]

    cmd = " ".join(cmd_args)
    dprint("get_kernel into host staging dir with cmd: '%s'" % cmd)
    vprint("Getting kernel for target '%s' on remote host '%s'" % (remote_target, tmap["host"]))
    rcode = os.system(cmd)
    if rcode != 0:
        error_out("Problem getting kernel using remote copy operation, on host '%s'" % hostname, 7)

    # use hosts copy_from_cmd to retrieve the staging dir
    copy_from_cmd = hmap.get("copy_from_cmd",
        "scp -r -q %(copy_args)s %(hostname)s:%(src)s %(dest)s")

    # now copy from host staging dir to local dest
    cp_dict = {"hostname": hostname, "src":staging_dir, "dest": outdir, "copy_args": ""}
    cmd = copy_from_cmd % cp_dict
    dprint("copying staging dir from host to dest with cmd: '%s'" % cmd)
    vprint("Copying kernel from host '%s' to directory '%s'" % (tmap["host"], outdir))
    rcode = os.system(cmd)
    if rcode != 0:
        error_out("Problem copying '%s' from staging dir on host %s to target" % (src, hostname), 7)

    # remove staging dir (be very careful with the path here!!)
    vprint("Removing staging directory on host")
    cmd_args = [exec_cmd] + exec_args + [hostname, "rm", "-rf", staging_dir]

    # double-check staging dir (make sure the path is not bogus)
    if " " in staging_dir or not staging_dir.startswith("/tmp"):
        error_out("Invalid staging_dir '%s' found!! - aborting!!" % staging_dir, 7)

    cmd = " ".join(cmd_args)
    dprint("removing staging dir with cmd: '%s'" % cmd)
    rcode = os.system(cmd)
    if rcode != 0:
        error_out("Problem removing staging directory for remote copy operation, on host '%s'" % hostname, 7)

    return


def config_val(op, config, value, line):
    if op=="y" or op=="m" or op=="1" or op=="s":
        new_val = "%s=%s\n" % (config, value)
    if op=="n":
        new_val = "# %s is not set\n" % (config)
    if op=="s+":
        #print("line="+line)
        # split the line (once) on '=' and take the second part
        old_val = line.split("=", 1)[1]

        # trim the quotes
        old_str = old_val.strip()[1:-1]
        new_str = value.strip()[1:-1]

        # append the old string and new string
        new_val = '%s="%s%s"\n' % (config, old_str, new_str)
        #print("old_val="+old_val)
        #print("new_val="+new_val)
    return new_val


def set_config_value_in_file(cfile, op, config, value):
    tmpfile = os.environ["TMPDIR"]+"/"+os.path.basename(cfile)+".tmp"
    #print("tmpfile = " + tmpfile)
    #print("cfile = " + cfile)
    lines = open(cfile,"rw").readlines()
    out = open(tmpfile,"w")

    pat = "(^# |^)%s[ =]" % config
    # scan file for config
    found = 0
    for line in lines:
        if re.match(pat,line):
            # replace this line in the output
            found = 1
            new_val = config_val(op, config, value, line)
            out.write(new_val)
            continue
        out.write(line)

    if not found:
        if op=="s+":
            print("error: missing %s, cannot append value %s" % (config, value))
            sys.exit(1)
        else:
            new_val = config_val(op, config, value, line)
            out.write(new_val)

    os.unlink(cfile)
    out.close()
    # rename doesn't work across distinct file systems
    shutil.move(tmpfile, cfile)

def do_set_config(tmap, kernel_dir, kopts):
    # kopt should be a list of option specs, separated by semi-colons
    # eg. CONFIG_FOO=y CONFIG_BAR=n CONFIG_BAZ=1235 CONFIG_STR+=" quiet"
    # back up the .config file
    cfile = kernel_dir+"/.config"
    bfile = kernel_dir+"/config.target-bak"
    print("Backing up current config file to %s" % os.path.basename(bfile))
    cmd = "cp %s %s" % (cfile, bfile)
    (rcode, result) = getstatusoutput(cmd)

    # now set the vars.
    for kopt_spec in kopts:
        print("  Setting %s" % kopt_spec)
        try:
            (config, value)=kopt_spec.split("=", 1)
        except:
            print("Invalid option specification: %s" % kopt_spec)
            continue
        # detect '+=' operation
        value = value.strip()
        op = value[0]
        if op == '"':
            op = 's'
        if config[-1]=="+":
            config = config[:-1]
            op = "s+"
        op = op.lower()
        if op>='0' and op<='9':
            op = '1'
        # check op for legal value:
        if op not in ('y','n','m','s','s+','1'):
            print("Invalid option specification: %s" % kopt_spec)
            continue
        set_config_value_in_file(cfile, op, config, value)


# split filepath by colon, and return prefix and remainder
# Returns '' as prefix (and the path unchanged) if there's # no colon, or
# if the prefix is something besides 'target' or 'target_bin'
def split_filepath_by_colon(filepath):
    try:
        (prefix, path) = filepath.split(':', 1)
    except:
        return ('', filepath)

    if prefix not in ['target', 'target_bin']:
        return ('', filepath)

    return (prefix, path)

def do_copy(tmap, objects):
    # copy must be one of:
    # 1) one file from host to a target directory or file
    # 2) more than one file from host to a target directory
    # 3) one file from target to a host directory or file
    # 4) more than one file from target to a host directory

    # we don't support host-to-host copies or target-to-target copies

    # FIXTHIS - need to handle invalid number of arguments in do_copy

    # if '-r' is specified, put it in 'copy_args' for sub-command:
    if objects[0] == '-r':
        os.environ["copy_args"] = "-r"
        del(objects[0])
    else:
        os.environ["copy_args"] = " "

    # find out direction of copy from the last argument
    (tspec, path) = split_filepath_by_colon(objects[-1])
    if tspec:    # we're copying *to* the target
        if tspec=="target":
            dest = path
        elif tspec=="target_bin":
            if "target_bin" in tmap:
                dest=tmap["target_bin"]+"/"+path
            else:
                dest="/usr/bin/" + path
        else:
            error_out("Invalid target prefix '%s' specified in dest path." % tspec, 6)

        # copy each file individually
        for src in objects[:-1]:
            os.environ["src"] = src
            os.environ["dest"] = dest
            exec_command(tmap, "copy_to")

    else:    # no tspec in destination, direction is *from* target
        dest = path
        for file in objects[:-1]:
            (tspec, src) = split_filepath_by_colon(file)
            if tspec != "target":
                error_out("Invalid target prefix '%s' specified in src path." % tspec, 6)
            os.environ["src"] = src
            os.environ["dest"] = dest
            exec_command(tmap, "copy_from")
    sys.exit(0)

def do_remote_copy(hmap, tmap, objects):
    global quiet, debug, verbose

    import random

    dprint("in do_remote_copy")

    # if '-r' is specified, put it in 'copy_args' for sub-commands:
    copy_args = ""
    if objects[0] == '-r':
        copy_args = "-r"
        del(objects[0])

    hostname = hmap.get("hostname", hmap["host"])
    full_target = tmap["target"]
    remote_target = full_target.split(":", 1)[1]
    ttc_has_debug = hmap.get("ttc_has_debug", "0")
    if ttc_has_debug in ["true", "True", "1"]:
        remote_ttc_has_debug = True
    else:
        remote_ttc_has_debug = False

    exec_cmd=hmap.get("exec_cmd", "/usr/bin/ssh")
    exec_args_str=hmap.get("exec_args", "-t -q -o ConnectTimeout=2")
    exec_args = shlex.split(exec_args_str)

    # set ttc global args
    extra_ttc_args = []
    if quiet: extra_ttc_args.append("-q")
    if verbose: extra_ttc_args.append("-v")
    if remote_ttc_has_debug and debug: extra_ttc_args.append("--debug")

    # make a staging area on the ttc host
    import random
    uid = random.randint(0,100000)
    staging_dir = "/tmp/ttc-cp-staging-%06d" % uid

    cmd_args = [exec_cmd] + exec_args + [hostname, "mkdir", "-p", staging_dir]

    cmd = " ".join(cmd_args)
    dprint("make staging dir with cmd: '%s'" % cmd)
    (rcode, result) = getstatusoutput(cmd)
    if result:
        print(result)
    if rcode != 0:
        error_out("Problem creating staging directory for remote copy operation, on host '%s'" % hostname, 7)

    # find out direction of copy from the last argument
    # if last arg starts with 'target' or 'target_bin', then
    # this is a 'put' or 'copy_to'
    (prefix, dest) = split_filepath_by_colon(objects[-1])

    rcode_all = 0
    if prefix:    # we're copying *to* the target
        # copy each item individually, to staging dir, then to target
        copy_to_cmd = hmap.get("copy_to_cmd",
            "scp -r %(copy_args)s %(src)s %(hostname)s:%(dest)s")
        for src in objects[:-1]:
            # copy src to host:staging
            cp_dict = {"hostname": hostname, "src":src, "dest": staging_dir, "copy_args": copy_args}
            # interpolate vars into the cmd string
            cmd = copy_to_cmd % cp_dict

            dprint("copying %s to staging dir with cmd: '%s'" % (src, cmd))
            (rcode, result) = getstatusoutput(cmd)
            if result:
                print(result)
            if rcode != 0:
                print_error("problem copying '%s' to staging dir on host %s" % (src, hostname))
                rcode_all = rcode
                continue

            # now copy from host:staging to target:dest
            cmd_args = [exec_cmd] + exec_args + [hostname, "ttc"] + \
                extra_ttc_args + [remote_target, "cp"]
            if copy_args:
                cmd_args += [copy_args]

            staging_src = staging_dir + "/" + os.path.basename(src)
            cmd_args += [staging_src, "target:"+dest]
            cmd = " ".join(cmd_args)
            dprint("copying %s to target dest with cmd: '%s'" % (src, cmd))
            (rcode, result) = getstatusoutput(cmd)
            if result:
                print(result)
            if rcode != 0:
                print_error("problem copying '%s' from staging dir on host %s to target" % (src, hostname))
                rcode_all = rcode

    else:
        # no prefix in last arg, direction is *from* target
        # ie - this is a 'get' or 'copy_from' and dest is local
        copy_from_cmd = hmap.get("copy_from_cmd",
            "scp -r %(copy_args)s %(hostname)s:%(src)s %(dest)s")

        for item in objects[:-1]:
            # copy from target:src to host:staging
            cmd_args = [exec_cmd] + exec_args + [hostname, "ttc"] + \
                extra_ttc_args + [remote_target, "cp"]

            if copy_args:
                cmd_args += [copy_args]

            src = item
            cmd_args += [src, staging_dir]
            cmd = " ".join(cmd_args)
            dprint("copying %s from target to staging with cmd: '%s'" % (src, cmd))
            (rcode, result) = getstatusoutput(cmd)
            if result:
                print(result)
            if rcode != 0:
                print_error("problem copying '%s' from target to staging dir on host %s" % (src, hostname))
                rcode_all = rcode
                continue

            # now copy from staging dir, to local dest
            (tspec, src) = split_filepath_by_colon(item)
            if tspec != "target":
                error_out("Invalid target prefix '%s' specified in src path '%s'." % (tspec, item), 6)

            staging_src = staging_dir + "/" + os.path.basename(src)
            cp_dict = {"hostname": hostname, "src":staging_src, "dest": dest, "copy_args": copy_args}
            cmd = copy_from_cmd % cp_dict
            dprint("copying %s from staging to dest with cmd: '%s'" % (src, cmd))
            (rcode, result) = getstatusoutput(cmd)
            if result:
                print(result)
            if rcode != 0:
                print_error("problem copying '%s' from staging dir on host %s to target" % (src, hostname))
                rcode_all = rcode

    # remove staging dir (be very careful with the path here!!)
    cmd_args = [exec_cmd] + exec_args + [hostname, "rm", "-r", staging_dir]

    # double-check staging dir (make sure the path is not bogus)
    if " " in staging_dir or not staging_dir.startswith("/tmp"):
        error_out("Invalid staging_dir '%s' found!! - aborting!!" % staging_dir, 7)

    cmd = " ".join(cmd_args)
    dprint("removing staging dir with cmd: '%s'" % cmd)
    (rcode, result) = getstatusoutput(cmd)
    if result:
        print(result)
    if rcode != 0:
        error_out("Problem removing staging directory for remote copy operation, on host '%s'" % hostname, 7)

    sys.exit(rcode_all)


def do_rm(tmap, objects):
    if not objects:
        error_out("Missing items to remove", 1)

    # remove each file individually
    for dest in objects:
        os.environ["dest"] = dest
        exec_command(tmap, "rm")
        sys.exit(0)


def do_wait_for(tmap, options):
    interval = 5
    # 99999 seconds is a little over 27 hours
    timeout = 99999
    if '-i' in options:
        interval = int(options[options.index('-i')+1])
        options.remove('-i')
        options.remove(str(interval))
    if '-t' in options:
        timeout = int(options[options.index('-t')+1])
        options.remove('-t')
        options.remove(str(timeout))

    cmd = options[0]
    print('Waiting (up to %d seconds) for "%s"...' % (timeout, cmd))

    i = 0
    while i < timeout:
        rcode = os.system(cmd) >> 8
        if rcode==0:
            break
        sys.stdout.write(".")
        sys.stdout.flush()
        time.sleep(interval)
        i = i + interval
    print()
    sys.exit(rcode)

class reservation_class:
    def __init__(self, target, user, start_time):
        self.target = target
        self.user = user
        self.start_time = start_time
        return

    def get_str(self):
        return """User '%s' currently has '%s' reserved."
  Reservation began at: %s
  Reservation will end: %s""" % \
    (self.user, self.target, self.start_time, self.end_time)


# return True if target is still reserved
def check_for_reservation_expiry(rmap, tmap):
    # check for reservation expiration
    end_time_str = rmap.get("end_time", "unknown")

    if end_time_str not in ["never", "unknown", "0-0-0_0:0:0"]:
        try:
            end_time = datetime.datetime.strptime(end_time_str, "%Y-%m-%d_%H:%M:%S")
        except ValueError:
            print("Warning: invalid reservation end_time of '%s' in reservation file" % end_time_str)

    now = datetime.datetime.now()
    if now > end_time:
        rfile = rmap["rfile"]
        try:
            os.unlink(rfile)
        except:
            print("Problem removing reservation file: %s" % rfile)

        # also, execute the release_cmd, if any
        if "release_cmd" in tmap:
            exec_command(tmap, "release")

        return False

    # target is still reserved
    return True


def get_reservation(tmap):
    try:
        real_board = tmap["real_board"]
    except:
        real_board = tmap["target"]
    rfile = rfile_fmt % (lockdir, real_board)
    reserved = os.path.isfile(rfile)

    if not reserved:
        return None

    # reservation file exists, read it for details
    temp_targets, temp_hosts = read_config(rfile, optional=False)
    rmap = temp_targets[real_board]
    rmap["rfile"] = rfile

    # check for reservation expiration
    reserved = check_for_reservation_expiry(rmap, tmap)
    if not reserved:
        return None

    res = reservation_class(real_board, rmap["user"], rmap["start_time"])
    res.rfile = rfile
    res.duration = rmap["duration"]
    res.end_time = rmap["end_time"]
    return res

# check the reservation for a target board
# returns if the user can access the board
# does not return if there's a reservation, not by this user
def check_reservation(tmap, command):
    dprint("Checking reservation")
    target = tmap["target"]
    res = get_reservation(tmap)

    # if there's a reservation, and it's not mine, error out
    if res and not res.user == os.environ["USER"]:
        print("Error: Can't perform command '%s'" % command)
        print(res.get_str())
        sys.exit(1)

# parse duration string in the form of: xxhyym
# returns number of minutes, or
#   0 on parse error
def parse_time_str(ts):
    minutes = 0
    if ('h' not in ts) and ('m' not in ts):
        return 0

    if 'h' in ts:
        hours, rest = ts.split('h', 1)
        if not re.match("^[0-9]+$", hours):
            return 0
        minutes += int(hours) * 60
        ts = rest

    if 'm' in ts:
        mins, rest = ts.split('m', 1)
        if rest:
            # 'm', if present, should be last element of string
            # if something follows 'm', it's an error
            return 0

        if not re.match("^[0-9]+$", mins):
            return 0
        minutes += int(mins)

    if rest:
        return 0

    return minutes


def do_reserve(tmap, options):
    req_start_time = "now"
    duration = "default"
    # handle -f (force) option
    force = 0
    if "-f" in options:
        force = 1
        options.remove("-f")

    # pasrse duration and start-time arguments
    while len(options):
        option = options[0]
        if option == "--start-time" or option == "-s":
            del options[0]
            try:
                start_time = options[1]
            except IndexError:
                error_out("Missing start time for '--start-time' option", 1)
            del options[0]
            del options[0]
        else:
            # interpret free arg duration, but check if one was already set
            if duration != "default":
                error_out("Unknown option '%s' for reserve command\nDuration already specified as '%s'" % (options[0], duration), 1)

            duration = options[0]
            del options[0]

    # create lock (reservations)  directory, if it doesn't exist
    if not os.path.isdir(lockdir):
        os.mkdir(lockdir)
        os.chmod(lockdir, 0o777)

    target = tmap["target"]
    try:
        real_board = tmap["real_board"]
    except:
        real_board = target
    user=os.environ["USER"]

    # calculate end_time
    if duration == "default":
        duration = "4h"

    duration_minutes = parse_time_str(duration)
    if not duration_minutes:
        error_out("Invalid duration of '%s' specified" % duration, 1)

    if req_start_time == "now":
        start_time = datetime.datetime.now()
        start_time_str = time.strftime("%Y-%m-%d_%H:%M:%S")
    else:
        # FIXTHIS - support future reservations
        # add to reservation queue, instead of current reservation
        error_out("Future reservations are not supported yet!", 1)

    delta_minutes = datetime.timedelta(minutes=int(duration_minutes))
    end_time = start_time + delta_minutes
    end_time_str = end_time.strftime("%Y-%m-%d_%H:%M:%S")

    # check for existing reservation
    res = get_reservation(tmap)

    if res:
       if user == res.user:
            print("You already have '%s' reserved." % target)
            # FIXTHIS - allow user to extend duration here?
            sys.exit(0)
       if not force:
            print("Error: Can't reserve '%s'" % target)
            print(res.get_str())
            sys.exit(1)

    # create a new reservation file
    # this might overwrite an old reservation file, if we're doing a force
    rfile = rfile_fmt % (lockdir, real_board)
    try:
        f = open(rfile, "w")
        f.write("target=%s\n" % real_board)
        f.write("target_alias=%s\n" % target)
        f.write("user=%s\n" % user)
        f.write("start_time=%s\n" % start_time_str)
        f.write("duration=%s\n" % duration)
        f.write("end_time=%s\n" % end_time_str)
        f.write("last_ttc_time=%s\n" % start_time_str)
        f.close()
    except:
        error_out("Could not create reservation file %s" % rfile, 5)

    try:
        os.chmod(rfile, 0o777)
    except:
        print("Could not chmod reservation file %s" % rfile)

    # also, execute the reserve_cmd, if any
    if "reserve_cmd" in tmap:
        exec_command(tmap, "reserve")

    print("Target board '%s' is reserved for user '%s'" % (target, user))
    sys.exit(0)

def do_release(tmap, options):
    res = get_reservation(tmap)

    target = tmap["target"]
    if not res:
        print("No reservation found for '%s'" % target)
        sys.exit(1)

    force = 0
    if "-f" in options:
        force = 1

    # cannot remove someone else's reservation, unless forced
    if res.user != os.environ["USER"] and not force:
        print("Error: Can't release reservation for '%s'" % target)
        print("User %s has the reservation." % res.user)
        print("Use 'ttc release -f' to force the release of the reservation.")
        sys.exit(1)

    try:
        real_board = tmap["real_board"]
    except:
        real_board = tmap["target"]
    rfile = rfile_fmt % (lockdir, real_board)

    # FIXTHIS - check for next reservation, instead of just deleting file

    try:
        os.unlink(rfile)
    except:
        print("Problem removing reservation file: %s" % rfile)

    # also, execute the release_cmd, if any
    if "release_cmd" in tmap:
        exec_command(tmap, "release")

    print("Released reservation for user %s for target '%s'" % (res.user, target))
    sys.exit(0)


import logging, logging.handlers
logger = None
def do_log_init():
    global logger
    if os.path.exists("/dev/log"):
        logger = logging.getLogger()
        logger.setLevel(logging.DEBUG)
        handler = logging.handlers.SysLogHandler('/dev/log')
        logger.addHandler(handler)
    else:
        print("ERROR: missing /dev/log - no logging performed")

    # FIXTHIS - could support file logging as well, here
    # should check TTC_SYSLOG, and use filename from that
    # maybe rename it to TTC_LOG instead (see LOG_ENV_VAR)

# overall, this information is pretty dang useless
def do_log(command, tmap, options):
    if logger:
        target = tmap["target"]
        logger.debug('ttc %s %s' % (target, command))

def get_remote_targets(hosts):
    # get target names from configured hosts
    remote_targets = []
    for host in hosts:
        dprint("reading data from host: %s" % host)
        hmap = hosts[host]
        hostname = hmap.get("hostname", host)

        # filter by target_pat_list, if specified
        target_pat_list = hmap.get("target_pat_list", ".*")
        tpats = target_pat_list.split(":")

        exec_cmd=hmap.get("exec_cmd", "/usr/bin/ssh")

        exec_args_str=hmap.get("exec_args", "-t -q -o ConnectTimeout=2")
        exec_args = shlex.split(exec_args_str)

        cmd_args = [exec_cmd] + exec_args + [hostname, "ttc", "-q", "list"]

        cmd = " ".join(cmd_args)

        dprint("cmd=%s" % cmd)
        (rcode, result) = getstatusoutput(cmd)
        dprint("rcode=%d" % rcode)
        if rcode != 0:
            print_error("problem reading targets from host %s" % host)
            continue

        for line in result.split('\n'):
            dprint("line=%s" % line)
            parts = line.strip().split(" ")
            target = parts[0]
            full_target = host+":"+target
            remote_targets.append(full_target)

    dprint("remote_targets=%s" % str(remote_targets))
    return remote_targets


def main():
    global verbose
    global quiet
    global use_statusoutput
    global debug

    if len(sys.argv)<2:
        error_out('Missing command\nUse "ttc help" to get usage help.', 1)

    # do logging to syslog, if user sets the logging environment variable
    if LOG_ENV_VAR in os.environ:
        do_log_init()

    # check for debug early
    if "--debug" in sys.argv:
        debug = True

    # read target information file for this host
    if os.path.exists(fuego_conf):
        targets, hosts = read_config(fuego_conf)
    else:
        targets, hosts = read_config(system_conf)

    # merge info from user config, if present
    if os.path.exists(user_conf):
        user_targets, user_hosts = read_config(user_conf)
        for tname in list(user_targets.keys()):
            tmap = user_targets[tname]
            # for bookkeeping, record the user file where
            # this info came from
            tmap["user_conf"] = user_conf
            if tname in targets:
                # if already present, merge the user info
                targets[tname].update(tmap)
            else:
                # else just add the user info
                targets[tname] = tmap
        for hname in list(user_hosts.keys()):
            hmap = user_hosts[hname]
            hmap["user_conf"] = user_conf
            if hname in hosts:
                hosts[hname].update(hmap)
            else:
                hosts[hname] = hmap

    # merge info from local config, if specified
    if LOCAL_CONF_ENV_VAR in os.environ:
        local_conf = os.environ[LOCAL_CONF_ENV_VAR]
        local_conf_list = local_conf.split(":")
        for local_conf in local_conf_list:
            local_targets, local_hosts = read_config(local_conf, optional=False)
            for tname in list(local_targets.keys()):
                tmap = local_targets[tname]
                # for bookkeeping, record the local file where
                # this info came from
                tmap["local_conf"] = local_conf
                if tname in targets:
                    # if already present, merge the local info
                    targets[tname].update(tmap)
                else:
                    # else just add the local info
                    targets[tname] = tmap
            for hname in list(local_hosts.keys()):
                hmap = local_hosts[hname]
                hmap["local_conf"] = local_conf
                if hname in hosts:
                    hosts[hname].update(hmap)
                else:
                    hosts[hname] = hmap

    target_list = list(targets.keys())
    target_alias = {}
    for tname in target_list:
        if "target_alias" in targets[tname]:
            talias = targets[tname]["target_alias"]
            target_alias[talias] = tname

    # perform inheritance for local targets, if any is specified
    # example of simple inheritance:
    # target=osk-ccache
    # inherit_from=osk
    # CROSS_COMPILE=ccache arm-sony-linux-gnueabi-
    #

    # do this multiple times, to catch nested inherit_froms
    # keep going until no changes are made in any attributes
    # (this implements a transitive closure)
    attribute_added=1
    while attribute_added:
        attribute_added = 0
        for tname in target_list:
            if "inherit_from" in targets[tname]:
                class_key_list = targets[tname]["inherit_from"]
                for class_key in class_key_list.split(","):
                    try:
                        class_attrs = targets[class_key.strip()]
                    except:
                        print("Error in config: missing config for %s specified in inherit_from attribute of target %s" % (class_key.strip(), tname))
                this_keys = list(targets[tname].keys())
                for key, attr in list(class_attrs.items()):
                    if key not in this_keys:
                        targets[tname][key] = attr
                        attribute_added=1

    if not targets:
        error_out("No valid targets were specified in any config file.\nHere is help on valid config files and locations:\n\n%s" % command_help["vars"][1], 3)

    # parse arguments
    command_list = ["list", "info", "help", "--help", "-h", "version",
        "console", "login", "status", "setenv", "kinstall",
        "kbuild", "mbuild", "minstall",
        "on", "off", "pos", "reset","reboot", "get_kernel", "get_config",
        "set_config", "cp", "rm", "wait_for", "fsbuild",
        "fsinstall", "run", "vars", "reserve", "release"]
    nontarget_commands = ["list", "help", "--help", "-h", "version", "vars"]
    board_mod_commands = ["console", "login", "kinstall", "minstall",
        "on", "off", "reset", "reboot", "cp", "rm", "fsinstall", "run"]
    easy_remote_commands = ["info", "login", "reserve", "release", "status",
        "reboot", "on", "off", "pos", "reset", "rm", "run", "version"]

    options = []

    target = ""
    command = ""
    quiet = 0
    verbose = 0
    use_statusoutput = 0
    check_reservation_flag = True
    # find command, target, and any arguments
    for i in range(1,len(sys.argv)):
        arg = sys.argv[i]
        if arg=="-q":
            quiet = 1
            continue
        if arg=="-v":
            verbose = 1
            continue
        if arg=="-c":
            use_statusoutput = 1
            continue
        if arg=="--debug":
            debug = True
            continue
        if arg=="--no-check":
            check_reservation_flag = False
            continue
        if arg == "run":
            # stop processing arguments
            # so you can do: 'ttc run help' or 'ttc run reboot'
            # or 'ttc run command -h'
            command = "run"
            options = sys.argv[i+1:]
            break
        if arg in command_list:
            # support "ttc <command> help"
            if (arg=="help" or arg=="-h" or arg=="--help") and command:
                options.append(command)
                command = arg
                continue

            # support "ttc help <command>" and "ttc run reboot"
            # -- where arg has same name as a legal ttc command
            if command:
                # this is an argument to the command
                # which was already found
                # note: check for 'help' arg (above) must come first
                options.append(arg)
            else:
                # normal "ttc <command>" case

                command = arg
            continue
        if arg in target_list:
            target = arg
            if verbose:
                print("Using target: " + target)
            continue
        if arg in list(target_alias.keys()):
            target = target_alias[arg]
            continue

        if not target:
            remote_targets = get_remote_targets(hosts)
            if arg in remote_targets:
                target = arg
                if verbose:
                    print("Using target: " + target)
                # synthesize a tmap for this target
                host = target.split(":")[0]
                tmap = {"target": target, "host": host}
                targets[target] = tmap
                continue

        options.append(arg)

    dprint("command='%s', options='%s'" % (command, options))

    if command=="help" or command=="--help" or command=="-h":
        usage(0, options)

    if command=="vars":
        options.append(command)
        usage(0, options)

    if command=="version":
        # this is weird, but handle version for ttc for remote target
        if target and is_remote(tmap):
            hmap = hosts[tmap["host"]]
            do_remote_command_exec(hmap, tmap, command, options)

        print("ttc: version %d.%d.%d" % VERSION)
        sys.exit(0)

    if command=="list":
        do_list(targets, hosts)

    # if no command recognized, return
    if not command:
        error_out('Missing or unregonized command\nUse "ttc help" to get usage help.', 1)

    # if command requires a target, but one was not specified,
    # try to get it from the environment
    if not target and command not in nontarget_commands:
        try:
            target = os.environ[TARGET_ENV_VAR]
            # check if target is OK
            if target not in targets and target not in remote_targets:
                error_out("Unknown target %s (specified by environment var. %s)" % (target, TARGET_ENV_VAR), 2)
            if target in remote_targets:
                # synthesize a tmap for this target
                host = target.split(":")[0]
                tmap = {"target": target, "host": host}
                targets[target] = tmap
            if verbose:
                print("Using target: " + target)
        except:
            error_out('Missing or unrecognized target for command "%s"\nUse "ttc help" to get usage help.' % command, 2)

    tmap = targets[target]

    # ex: target=my_board
    # copy_to_cmd=cp $src /target/%(foo)s/$dest
    # note difference between internally expanded macros %(var)s, and
    # externally expanded shell environment variables $var

    def expand_macros(str, d):
        new_str = str
        cpat=re.compile(r"%[(]\w*?[)]s")
        m = cpat.search(new_str)
        max_subs = 20
        i = 0
        while m and i<max_subs:
            part1 = new_str[:m.start()]
            macro = new_str[m.start():m.end()]
            part2 = new_str[m.end():]
            try:
                value = macro % d
            except:
                value = "<unknown>"
                print_error("missing value for named macro '%s'" % macro)
            new_str = part1+value+part2
            m = cpat.search(new_str)
            i += 1
        return new_str

    # read BUILDDIR from environment before macro expansion
    if "BUILDDIR" in os.environ:
        tmap["BUILDDIR"] = os.environ["BUILDDIR"]

    # expand macros
    for name,value in list(tmap.items()):
        tmap[name] = expand_macros(value, tmap)

        # export some special environment variables
        if "SSHPASS" in tmap:
            os.environ["SSHPASS"] = tmap["SSHPASS"]

    # log if env 'TTC_LOG' is set.
    do_log(command, tmap, options)

    # all non-target commands have been handled
    if command in board_mod_commands and check_reservation_flag:
        check_reservation(tmap, command)

    if is_remote(tmap) and command in easy_remote_commands:
        hmap = hosts[tmap["host"]]
        do_remote_command_exec(hmap, tmap, command, options)

    # do local environment setup
    do_setenv(tmap)

    # process the command
    if command=="info":
        do_info(tmap, options)

    if command=="status":
        do_status(tmap)

    if command=="reserve":
        do_reserve(tmap, options)

    if command=="release":
        do_release(tmap, options)

    if command in ["kinstall", "minstall", "reset", "reboot", "fsinstall", \
        "kbuild", "mbuild", "on", "off", "pos", "fsbuild"]:
        exec_command(tmap, command)
        if (command=="reset" or command=="reboot") and \
            ("-w" in options):
            try:
                reset_delay = int(tmap["reset_delay"])
            except:
                reset_delay = 30
            print("Waiting %d seconds for target board to reset..." % reset_delay)
            time.sleep(reset_delay)
        sys.exit(0)

    if command=="console" or command=="login":
        exec_command(tmap, command, 1)
        sys.exit(0)

    if command=="setenv":
        # if user is not outputing an export list, user gets a sub-shell
        if "-o" not in options:
            options.append("-s")
        do_setenv(tmap, options)

    if command=="get_kernel":
        do_get_kernel(tmap, hosts, options)
        sys.exit(0)

    if command=="run":
        do_run(tmap, options)
        # this does not return
        sys.exit(0)

    if command=="get_config":
        # set directory to output kernel to (or place config in)
        if "-o" in options:
            # override the KBUILD_OUTPUT directory in the environment
            # FIXTHIS - this arg parsing is not robust
            outdir = options[options.index("-o")+1]
            os.environ["KBUILD_OUTPUT"] = outdir

        # create the build output directory, if it does not exist
        if "KBUILD_OUTPUT" in os.environ:
            outdir = os.environ["KBUILD_OUTPUT"]
            if not os.path.exists(outdir):
                print("Warning: missing build output directory '%s'" % outdir)
                sys.stdout.write("Trying to create it now...")
                cmd = "install -d %s" % outdir
                (rcode, result) = getstatusoutput(cmd)
                if rcode:
                    print()
                    print("Error: Could not create build output directory '%s'" % outdir)
                    print("Result='%s'" % result)
                else:
                    print("OK")

        exec_command(tmap, command)
        sys.exit(0)

    if command=="set_config":
        # set an individual kernel config
        # first, set directory where .config is found
        outdir = "."
        # FIXTHIS - KERNEL_SRC only works if cwd is "up one"
        #if os.environ.has_key("KERNEL_SRC"):
        #    outdir = os.environ["KERNEL_SRC"]
        if "KBUILD_OUTPUT" in os.environ:
            outdir = os.environ["KBUILD_OUTPUT"]
        if "-o" in options:
            # override the KBUILD_OUTPUT directory in the environment
            # FIXTHIS - this arg parsing is not robust
            outdir = options[options.index("-o")+1]

        do_set_config(tmap, outdir, options)

    if command=="cp":
        if is_remote(tmap):
            hmap = hosts[tmap["host"]]
            do_remote_copy(hmap, tmap, options)
        else:
            do_copy(tmap, options)

    if command=="rm":
        do_rm(tmap, options)

    if command=="wait_for":
        do_wait_for(tmap, options)


if __name__=="__main__":
    main()
